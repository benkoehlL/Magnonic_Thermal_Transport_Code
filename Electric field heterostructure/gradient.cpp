#include <iostream>
#include <fstream>
#include <sstream>
#include <cmath>
#include "parameter.h"

using namespace std;

int main(){
    double parameter = 0.2;
    double* E = new double[2*systemsize];//phi in first half, theta in second half    
    for(int ix=0;ix<xsize;ix++){
            for(int y=0;y<ysize;y++){
                if(ix>=freefieldsize && ix<(freefieldsize+fieldsize)){
                    E[ix*ysize+y] = parameter;
                    E[ix*ysize+y+systemsize] = parameter;
                }
                else{
                    E[ix*ysize+y+systemsize] = 0.0;
                }
                //cout << ix << "\t" << y << "\t" << E[ix*ysize+y] << "\t" << E[ix*ysize+y+systemsize] << endl;
            }
    }
    double* state = new double[2*systemsize];//phi in first half, theta in second half
    double* gradient = new double[2*systemsize];//phi in first half, theta in second half
    for(int x=0; x<xsize;x++){
        for(int y=0;y<ysize;y++){
            state[x*ysize+y] = 0.0*M_PI;
            state[x*ysize+y+systemsize] = double((abs(x-y)%2));
            //cout << x << "\t" << y << "\t" << state[x*ysize+y+systemsize] << endl;
        }
    }
    
    int site,xposneighbour,yposneighbour,xnegneighbour,ynegneighbour;
    for(int x=0;x<xsize;x++){
        for(int y=0;y<ysize;y++){
            site = x*ysize+y;
            xposneighbour = (x+1)*ysize+y;
            xnegneighbour = (x-1)*ysize+y;
            yposneighbour = x*ysize+(y+1);
            ynegneighbour = x*ysize+(y-1);
            if((x>0 && x<xsize-1) && (y>0 && y<ysize-1)){
                //phi gradient
                gradient[site]= 
                        //alpha=phi_i-phi_j derivatives:
                        0.5*(cos(state[site+systemsize]-state[xposneighbour+systemsize])
                                *(-sin(state[site]-state[xposneighbour]))
                            +cos(state[xnegneighbour+systemsize]-state[site+systemsize])
                                *(sin(state[xnegneighbour]-state[site]))
                            +cos(state[site+systemsize]-state[yposneighbour+systemsize])
                                *(-sin(state[site]-state[yposneighbour]))
                            +cos(state[ynegneighbour+systemsize]-state[site+systemsize])
                                *(sin(state[ynegneighbour]-state[site]))
                            +cos(state[site+systemsize]+state[xposneighbour+systemsize])
                                *(sin(state[site]-state[xposneighbour]))
                            +cos(state[xnegneighbour+systemsize]+state[site+systemsize])
                                *(-sin(state[xnegneighbour]-state[site]))
                            +cos(state[site+systemsize]+state[yposneighbour+systemsize])
                                *(sin(state[site]-state[yposneighbour]))
                            +cos(state[ynegneighbour+systemsize]+state[site+systemsize])
                                *(-sin(state[ynegneighbour]-state[site])))
                        -0.5*E[site]*(sin(state[site+systemsize]+state[xposneighbour+systemsize])
                                    *sin(0.5*(state[site]+state[xposneighbour]))
                                    *cos(0.5*(state[site]-state[xposneighbour]))
                                 +sin(state[site+systemsize]-state[xposneighbour+systemsize])
                                    *cos(0.5*(state[site]+state[xposneighbour]))
                                    *sin(0.5*(state[site]-state[xposneighbour])))
                        +0.5*E[site+systemsize]*(sin(state[site+systemsize]+state[yposneighbour+systemsize])
                                    *cos(0.5*(state[site]-state[yposneighbour]))
                                    *cos(0.5*(state[site]+state[yposneighbour]))
                                 -sin(state[site+systemsize]-state[yposneighbour+systemsize])
                                    *sin(0.5*(state[site]+state[yposneighbour]))
                                    *sin(0.5*(state[site]-state[yposneighbour])))
                        -0.5*E[xnegneighbour]*(-sin(state[xnegneighbour+systemsize]+state[site+systemsize])
                                    *sin(0.5*(state[xnegneighbour]+state[site]))
                                    *cos(0.5*(state[xnegneighbour]-state[site]))
                                 -sin(state[xnegneighbour+systemsize]-state[site+systemsize])
                                    *cos(0.5*(state[xnegneighbour]+state[site]))
                                    *sin(0.5*(state[xnegneighbour]-state[site])))
                        -0.5*E[ynegneighbour+systemsize]*(sin(state[ynegneighbour+systemsize]+state[site+systemsize])
                                    *cos(0.5*(state[ynegneighbour]-state[site]))
                                    *cos(0.5*(state[ynegneighbour]+state[site]))
                                 -sin(state[ynegneighbour+systemsize]-state[site+systemsize])
                                    *sin(0.5*(state[ynegneighbour]+state[site]))
                                    *sin(0.5*(state[ynegneighbour]-state[site])))
                        //beta = phi_i+ phi_j derivatives:
                        -0.5*E[site]*(sin(state[site+systemsize]+state[xposneighbour+systemsize])
                                    *cos(0.5*(state[site]+state[xposneighbour]))
                                    *sin(0.5*(state[site]-state[xposneighbour]))
                                 +sin(state[site+systemsize]-state[xposneighbour+systemsize])
                                    *sin(0.5*(state[site]+state[xposneighbour]))
                                    *cos(0.5*(state[site]-state[xposneighbour])))
                        +0.5*E[site+systemsize]*(sin(state[site+systemsize]+state[yposneighbour+systemsize])
                                    *sin(0.5*(state[site]-state[yposneighbour]))
                                    *(-sin(0.5*(state[site]+state[yposneighbour])))
                                 +sin(state[site+systemsize]-state[yposneighbour+systemsize])
                                    *cos(0.5*(state[site]+state[yposneighbour]))
                                    *cos(0.5*(state[site]-state[yposneighbour])))
                        -0.5*E[xnegneighbour]*(sin(state[xnegneighbour+systemsize]+state[site+systemsize])
                                    *cos(0.5*(state[xnegneighbour]+state[site]))
                                    *sin(0.5*(state[xnegneighbour]-state[site]))
                                 +sin(state[xnegneighbour+systemsize]-state[site+systemsize])
                                    *(-sin(0.5*(state[xnegneighbour]+state[site])))
                                    *cos(0.5*(state[xnegneighbour]-state[site])))
                        +0.5*E[ynegneighbour+systemsize]*(sin(state[ynegneighbour+systemsize]+state[site+systemsize])
                                    *sin(0.5*(state[ynegneighbour]-state[site]))
                                    *(-sin(0.5*(state[ynegneighbour]+state[site])))
                                 +sin(state[ynegneighbour+systemsize]-state[site+systemsize])
                                    *cos(0.5*(state[ynegneighbour]+state[site]))
                                    *cos(0.5*(state[ynegneighbour]-state[site])));
                //theta gradient
                gradient[site+systemsize]=
                        0.5*(-sin(state[site+systemsize]-state[xposneighbour+systemsize])
                                *(cos(state[site]-state[xposneighbour])+1.0)
                             -sin(state[site+systemsize]+state[xposneighbour+systemsize])
                                *(1.0-cos(state[site]-state[xposneighbour]))
                             -sin(state[site+systemsize]-state[yposneighbour+systemsize])
                                *(cos(state[site]-state[yposneighbour])+1.0)
                             -sin(state[site+systemsize]+state[yposneighbour+systemsize])
                                *(1.0-cos(state[site]-state[yposneighbour]))
                             +sin(state[xnegneighbour+systemsize]-state[site+systemsize])
                                *(cos(state[xnegneighbour]-state[site])+1.0)
                             -sin(state[xnegneighbour+systemsize]+state[site+systemsize])
                                *(1.0-cos(state[xnegneighbour]-state[site]))
                             +sin(state[ynegneighbour+systemsize]-state[site+systemsize])
                                *(cos(state[ynegneighbour]-state[site])+1.0)
                             -sin(state[ynegneighbour+systemsize]+state[site+systemsize])
                                *(1.0-cos(state[ynegneighbour]-state[site])))
                        -E[site]*(cos(state[site+systemsize]+state[xposneighbour+systemsize])
                                *sin(0.5*(state[site]+state[xposneighbour]))
                                *sin(0.5*(state[site]-state[xposneighbour]))
                             -cos(state[site+systemsize]-state[xposneighbour+systemsize])
                                *cos(0.5*(state[site]+state[xposneighbour]))
                                *cos(0.5*(state[site]-state[xposneighbour])))
                        +E[site+systemsize]*(cos(state[site+systemsize]+state[yposneighbour+systemsize])
                                *sin(0.5*(state[site]-state[yposneighbour]))
                                *cos(0.5*(state[site]+state[yposneighbour]))
                             +cos(state[site+systemsize]-state[yposneighbour+systemsize])
                                *cos(0.5*(state[site]-state[yposneighbour]))
                                *sin(0.5*(state[site]+state[yposneighbour])))
                        -E[xnegneighbour]*(cos(state[xnegneighbour+systemsize]+state[site+systemsize])
                                *sin(0.5*(state[xnegneighbour]+state[site]))
                                *sin(0.5*(state[xnegneighbour]-state[site]))
                             +cos(state[xnegneighbour+systemsize]-state[site+systemsize])
                                *cos(0.5*(state[xnegneighbour]+state[site]))
                                *cos(0.5*(state[xnegneighbour]-state[site])))
                        +E[ynegneighbour+systemsize]*(cos(state[ynegneighbour+systemsize]+state[site+systemsize])
                                *sin(0.5*(state[ynegneighbour]-state[site]))
                                *cos(0.5*(state[ynegneighbour]+state[site]))
                             -cos(state[ynegneighbour+systemsize]-state[site+systemsize])
                                *sin(0.5*(state[ynegneighbour]+state[site]))
                                *cos(0.5*(state[ynegneighbour]-state[site])));
            }
            else if(x==0 && (y!=0 && y!=ysize-1)){
                //phi gradient
                gradient[site] = 
                        //alpha=phi_i-phi_j derivatives:
                        0.5*(cos(state[site+systemsize]-state[xposneighbour+systemsize])
                                *(-sin(state[site]-state[xposneighbour]))
                            +cos(state[site+systemsize]-state[yposneighbour+systemsize])
                                *(-sin(state[site]-state[yposneighbour]))
                            +cos(state[ynegneighbour+systemsize]-state[site+systemsize])
                                *(sin(state[ynegneighbour]-state[site]))
                            +cos(state[site+systemsize]+state[xposneighbour+systemsize])
                                *(sin(state[site]-state[xposneighbour]))
                            +cos(state[site+systemsize]+state[yposneighbour+systemsize])
                                *(sin(state[site]-state[yposneighbour]))
                            +cos(state[ynegneighbour+systemsize]+state[site+systemsize])
                                *(-sin(state[ynegneighbour]-state[site])))
                        -0.5*E[site]*(sin(state[site+systemsize]+state[xposneighbour+systemsize])
                                    *sin(0.5*(state[site]+state[xposneighbour]))
                                    *cos(0.5*(state[site]-state[xposneighbour]))
                                 +sin(state[site+systemsize]-state[xposneighbour+systemsize])
                                    *cos(0.5*(state[site]+state[xposneighbour]))
                                    *sin(0.5*(state[site]-state[xposneighbour])))
                        +0.5*E[site+systemsize]*(sin(state[site+systemsize]+state[yposneighbour+systemsize])
                                    *cos(0.5*(state[site]-state[yposneighbour]))
                                    *cos(0.5*(state[site]+state[yposneighbour]))
                                 -sin(state[site+systemsize]-state[yposneighbour+systemsize])
                                    *sin(0.5*(state[site]+state[yposneighbour]))
                                    *sin(0.5*(state[site]-state[yposneighbour])))
                        -0.5*E[ynegneighbour+systemsize]*(sin(state[ynegneighbour+systemsize]+state[site+systemsize])
                                    *cos(0.5*(state[ynegneighbour]-state[site]))
                                    *cos(0.5*(state[ynegneighbour]+state[site]))
                                 -sin(state[ynegneighbour+systemsize]-state[site+systemsize])
                                    *sin(0.5*(state[ynegneighbour]+state[site]))
                                    *sin(0.5*(state[ynegneighbour]-state[site])))
                        //beta = phi_i+ phi_j derivatives:
                        -0.5*E[site]*(sin(state[site+systemsize]+state[xposneighbour+systemsize])
                                    *cos(0.5*(state[site]+state[xposneighbour]))
                                    *sin(0.5*(state[site]-state[xposneighbour]))
                                 +sin(state[site+systemsize]-state[xposneighbour+systemsize])
                                    *sin(0.5*(state[site]+state[xposneighbour]))
                                    *cos(0.5*(state[site]-state[xposneighbour])))
                        +0.5*E[site+systemsize]*(sin(state[site+systemsize]+state[yposneighbour+systemsize])
                                    *sin(0.5*(state[site]-state[yposneighbour]))
                                    *(-sin(0.5*(state[site]+state[yposneighbour])))
                                 +sin(state[site+systemsize]-state[yposneighbour+systemsize])
                                    *cos(0.5*(state[site]+state[yposneighbour]))
                                    *cos(0.5*(state[site]-state[yposneighbour])))
                        +0.5*E[ynegneighbour+systemsize]*(sin(state[ynegneighbour+systemsize]+state[site+systemsize])
                                    *sin(0.5*(state[ynegneighbour]-state[site]))
                                    *(-sin(0.5*(state[ynegneighbour]+state[site])))
                                 +sin(state[ynegneighbour+systemsize]-state[site+systemsize])
                                    *cos(0.5*(state[ynegneighbour]+state[site]))
                                    *cos(0.5*(state[ynegneighbour]-state[site])));
                //theta gradient
                gradient[site+systemsize]=
                        0.5*(-sin(state[site+systemsize]-state[xposneighbour+systemsize])
                                *(cos(state[site]-state[xposneighbour])+1.0)
                             -sin(state[site+systemsize]+state[xposneighbour+systemsize])
                                *(1.0-cos(state[site]-state[xposneighbour]))
                             -sin(state[site+systemsize]-state[yposneighbour+systemsize])
                                *(cos(state[site]-state[yposneighbour])+1.0)
                             -sin(state[site+systemsize]+state[yposneighbour+systemsize])
                                *(1.0-cos(state[site]-state[yposneighbour]))
                             +sin(state[ynegneighbour+systemsize]-state[site+systemsize])
                                *(cos(state[ynegneighbour]-state[site])+1.0)
                             -sin(state[ynegneighbour+systemsize]+state[site+systemsize])
                                *(1.0-cos(state[ynegneighbour]-state[site])))
                        -E[site]*(cos(state[site+systemsize]+state[xposneighbour+systemsize])
                                *sin(0.5*(state[site]+state[xposneighbour]))
                                *sin(0.5*(state[site]-state[xposneighbour]))
                             -cos(state[site+systemsize]-state[xposneighbour+systemsize])
                                *cos(0.5*(state[site]+state[xposneighbour]))
                                *cos(0.5*(state[site]-state[xposneighbour])))
                        +E[site+systemsize]*(cos(state[site+systemsize]+state[yposneighbour+systemsize])
                                *sin(0.5*(state[site]-state[yposneighbour]))
                                *cos(0.5*(state[site]+state[yposneighbour]))
                             +cos(state[site+systemsize]-state[yposneighbour+systemsize])
                                *cos(0.5*(state[site]-state[yposneighbour]))
                                *sin(0.5*(state[site]+state[yposneighbour])))
                        +E[ynegneighbour+systemsize]*(cos(state[ynegneighbour+systemsize]+state[site+systemsize])
                                *sin(0.5*(state[ynegneighbour]-state[site]))
                                *cos(0.5*(state[ynegneighbour]+state[site]))
                             -cos(state[ynegneighbour+systemsize]-state[site+systemsize])
                                *sin(0.5*(state[ynegneighbour]+state[site]))
                                *cos(0.5*(state[ynegneighbour]-state[site])))
                ;
            }
            else if(x==xsize-1 && (y!=0 && y!=ysize-1)){
                //phi gradient
                gradient[site]= 
                        //alpha=phi_i-phi_j derivatives:
                        0.5*(+cos(state[xnegneighbour+systemsize]-state[site+systemsize])
                                *(sin(state[xnegneighbour]-state[site]))
                            +cos(state[site+systemsize]-state[yposneighbour+systemsize])
                                *(-sin(state[site]-state[yposneighbour]))
                            +cos(state[ynegneighbour+systemsize]-state[site+systemsize])
                                *(sin(state[ynegneighbour]-state[site]))
                            +cos(state[xnegneighbour+systemsize]+state[site+systemsize])
                                *(-sin(state[xnegneighbour]-state[site]))
                            +cos(state[site+systemsize]+state[yposneighbour+systemsize])
                                *(sin(state[site]-state[yposneighbour]))
                            +cos(state[ynegneighbour+systemsize]+state[site+systemsize])
                                *(-sin(state[ynegneighbour]-state[site])))
                        +0.5*E[site+systemsize]*(sin(state[site+systemsize]+state[yposneighbour+systemsize])
                                    *cos(0.5*(state[site]-state[yposneighbour]))
                                    *cos(0.5*(state[site]+state[yposneighbour]))
                                 -sin(state[site+systemsize]-state[yposneighbour+systemsize])
                                    *sin(0.5*(state[site]+state[yposneighbour]))
                                    *sin(0.5*(state[site]-state[yposneighbour])))
                        -0.5*E[xnegneighbour]*(-sin(state[xnegneighbour+systemsize]+state[site+systemsize])
                                    *sin(0.5*(state[xnegneighbour]+state[site]))
                                    *cos(0.5*(state[xnegneighbour]-state[site]))
                                 -sin(state[xnegneighbour+systemsize]-state[site+systemsize])
                                    *cos(0.5*(state[xnegneighbour]+state[site]))
                                    *sin(0.5*(state[xnegneighbour]-state[site])))
                        -0.5*E[ynegneighbour+systemsize]*(sin(state[ynegneighbour+systemsize]+state[site+systemsize])
                                    *cos(0.5*(state[ynegneighbour]-state[site]))
                                    *cos(0.5*(state[ynegneighbour]+state[site]))
                                 -sin(state[ynegneighbour+systemsize]-state[site+systemsize])
                                    *sin(0.5*(state[ynegneighbour]+state[site]))
                                    *sin(0.5*(state[ynegneighbour]-state[site])))
                        //beta = phi_i+ phi_j derivatives:
                        +0.5*E[site+systemsize]*(sin(state[site+systemsize]+state[yposneighbour+systemsize])
                                    *sin(0.5*(state[site]-state[yposneighbour]))
                                    *(-sin(0.5*(state[site]+state[yposneighbour])))
                                 +sin(state[site+systemsize]-state[yposneighbour+systemsize])
                                    *cos(0.5*(state[site]+state[yposneighbour]))
                                    *cos(0.5*(state[site]-state[yposneighbour])))
                        -0.5*E[xnegneighbour]*(sin(state[xnegneighbour+systemsize]+state[site+systemsize])
                                    *(-cos(0.5*(state[xnegneighbour]+state[site])))
                                    *sin(0.5*(state[xnegneighbour]-state[site]))
                                 -sin(state[xnegneighbour+systemsize]-state[site+systemsize])
                                    *sin(0.5*(state[xnegneighbour]+state[site]))
                                    *cos(0.5*(state[xnegneighbour]-state[site])))
                        +0.5*E[ynegneighbour+systemsize]*(sin(state[ynegneighbour+systemsize]+state[site+systemsize])
                                    *sin(0.5*(state[ynegneighbour]-state[site]))
                                    *(sin(0.5*(state[ynegneighbour]+state[site])))
                                 -sin(state[ynegneighbour+systemsize]-state[site+systemsize])
                                    *cos(0.5*(state[ynegneighbour]+state[site]))
                                    *cos(0.5*(state[ynegneighbour]-state[site])))
                        ;
                //theta gradient
                gradient[site+systemsize]=
                        0.5*(-sin(state[site+systemsize]-state[yposneighbour+systemsize])
                                *(cos(state[site]-state[yposneighbour])+1.0)
                             -sin(state[site+systemsize]+state[yposneighbour+systemsize])
                                *(1.0-cos(state[site]-state[yposneighbour]))
                             +sin(state[xnegneighbour+systemsize]-state[site+systemsize])
                                *(cos(state[xnegneighbour]-state[site])+1.0)
                             -sin(state[xnegneighbour+systemsize]+state[site+systemsize])
                                *(1.0-cos(state[xnegneighbour]-state[site]))
                             +sin(state[ynegneighbour+systemsize]-state[site+systemsize])
                                *(cos(state[ynegneighbour]-state[site])+1.0)
                             -sin(state[ynegneighbour+systemsize]+state[site+systemsize])
                                *(1.0-cos(state[ynegneighbour]-state[site])))
                        +E[site+systemsize]*(cos(state[site+systemsize]+state[yposneighbour+systemsize])
                                *sin(0.5*(state[site]-state[yposneighbour]))
                                *cos(0.5*(state[site]+state[yposneighbour]))
                             +cos(state[site+systemsize]-state[yposneighbour+systemsize])
                                *cos(0.5*(state[site]-state[yposneighbour]))
                                *sin(0.5*(state[site]+state[yposneighbour])))
                        -E[xnegneighbour]*(cos(state[xnegneighbour+systemsize]+state[site+systemsize])
                                *sin(0.5*(state[xnegneighbour]+state[site]))
                                *sin(0.5*(state[xnegneighbour]-state[site]))
                             +cos(state[xnegneighbour+systemsize]-state[site+systemsize])
                                *cos(0.5*(state[xnegneighbour]+state[site]))
                                *cos(0.5*(state[xnegneighbour]-state[site])))
                        +E[ynegneighbour+systemsize]*(cos(state[ynegneighbour+systemsize]+state[site+systemsize])
                                *sin(0.5*(state[ynegneighbour]-state[site]))
                                *cos(0.5*(state[ynegneighbour]+state[site]))
                             -cos(state[ynegneighbour+systemsize]-state[site+systemsize])
                                *sin(0.5*(state[ynegneighbour]+state[site]))
                                *cos(0.5*(state[ynegneighbour]-state[site])))
                ;
            }
            else if(y==0 && (x!=0 && x!=xsize-1)){
                //phi gradient
                gradient[site]= 
                        //alpha=phi_i-phi_j derivatives:
                        0.5*(cos(state[site+systemsize]-state[xposneighbour+systemsize])
                                *(-sin(state[site]-state[xposneighbour]))
                            +cos(state[xnegneighbour+systemsize]-state[site+systemsize])
                                *(sin(state[xnegneighbour]-state[site]))
                            +cos(state[site+systemsize]-state[yposneighbour+systemsize])
                                *(-sin(state[site]-state[yposneighbour]))
                            +cos(state[site+systemsize]+state[xposneighbour+systemsize])
                                *(sin(state[site]-state[xposneighbour]))
                            +cos(state[xnegneighbour+systemsize]+state[site+systemsize])
                                *(-sin(state[xnegneighbour]-state[site]))
                            +cos(state[site+systemsize]+state[yposneighbour+systemsize])
                                *(sin(state[site]-state[yposneighbour])))
                        -0.5*E[site]*(sin(state[site+systemsize]+state[xposneighbour+systemsize])
                                    *sin(0.5*(state[site]+state[xposneighbour]))
                                    *cos(0.5*(state[site]-state[xposneighbour]))
                                 +sin(state[site+systemsize]-state[xposneighbour+systemsize])
                                    *cos(0.5*(state[site]+state[xposneighbour]))
                                    *sin(0.5*(state[site]-state[xposneighbour])))
                        +0.5*E[site+systemsize]*(sin(state[site+systemsize]+state[yposneighbour+systemsize])
                                    *cos(0.5*(state[site]-state[yposneighbour]))
                                    *cos(0.5*(state[site]+state[yposneighbour]))
                                 -sin(state[site+systemsize]-state[yposneighbour+systemsize])
                                    *sin(0.5*(state[site]+state[yposneighbour]))
                                    *sin(0.5*(state[site]-state[yposneighbour])))
                        -0.5*E[xnegneighbour]*(-sin(state[xnegneighbour+systemsize]+state[site+systemsize])
                                    *sin(0.5*(state[xnegneighbour]+state[site]))
                                    *cos(0.5*(state[xnegneighbour]-state[site]))
                                 -sin(state[xnegneighbour+systemsize]-state[site+systemsize])
                                    *cos(0.5*(state[xnegneighbour]+state[site]))
                                    *sin(0.5*(state[xnegneighbour]-state[site])))
                        //beta = phi_i+ phi_j derivatives:
                        -0.5*E[site]*(sin(state[site+systemsize]+state[xposneighbour+systemsize])
                                    *cos(0.5*(state[site]+state[xposneighbour]))
                                    *sin(0.5*(state[site]-state[xposneighbour]))
                                 +sin(state[site+systemsize]-state[xposneighbour+systemsize])
                                    *sin(0.5*(state[site]+state[xposneighbour]))
                                    *cos(0.5*(state[site]-state[xposneighbour])))
                        +0.5*E[site+systemsize]*(sin(state[site+systemsize]+state[yposneighbour+systemsize])
                                    *sin(0.5*(state[site]-state[yposneighbour]))
                                    *(-sin(0.5*(state[site]+state[yposneighbour])))
                                 +sin(state[site+systemsize]-state[yposneighbour+systemsize])
                                    *cos(0.5*(state[site]+state[yposneighbour]))
                                    *cos(0.5*(state[site]-state[yposneighbour])))
                        -0.5*E[xnegneighbour]*(sin(state[xnegneighbour+systemsize]+state[site+systemsize])
                                    *cos(0.5*(state[xnegneighbour]+state[site]))
                                    *sin(0.5*(state[xnegneighbour]-state[site]))
                                 +sin(state[xnegneighbour+systemsize]-state[site+systemsize])
                                    *(-sin(0.5*(state[xnegneighbour]+state[site])))
                                    *cos(0.5*(state[xnegneighbour]-state[site])))
                ;
                //theta gradient
                gradient[site+systemsize]=
                        0.5*(-sin(state[site+systemsize]-state[xposneighbour+systemsize])
                                *(cos(state[site]-state[xposneighbour])+1.0)
                             -sin(state[site+systemsize]+state[xposneighbour+systemsize])
                                *(1.0-cos(state[site]-state[xposneighbour]))
                             -sin(state[site+systemsize]-state[yposneighbour+systemsize])
                                *(cos(state[site]-state[yposneighbour])+1.0)
                             -sin(state[site+systemsize]+state[yposneighbour+systemsize])
                                *(1.0-cos(state[site]-state[yposneighbour]))
                             +sin(state[xnegneighbour+systemsize]-state[site+systemsize])
                                *(cos(state[xnegneighbour]-state[site])+1.0)
                             -sin(state[xnegneighbour+systemsize]+state[site+systemsize])
                                *(1.0-cos(state[xnegneighbour]-state[site])))
                        -E[site]*(cos(state[site+systemsize]+state[xposneighbour+systemsize])
                                *sin(0.5*(state[site]+state[xposneighbour]))
                                *sin(0.5*(state[site]-state[xposneighbour]))
                             -cos(state[site+systemsize]-state[xposneighbour+systemsize])
                                *cos(0.5*(state[site]+state[xposneighbour]))
                                *cos(0.5*(state[site]-state[xposneighbour])))
                        +E[site+systemsize]*(cos(state[site+systemsize]+state[yposneighbour+systemsize])
                                *sin(0.5*(state[site]-state[yposneighbour]))
                                *cos(0.5*(state[site]+state[yposneighbour]))
                             +cos(state[site+systemsize]-state[yposneighbour+systemsize])
                                *cos(0.5*(state[site]-state[yposneighbour]))
                                *sin(0.5*(state[site]+state[yposneighbour])))
                        -E[xnegneighbour]*(cos(state[xnegneighbour+systemsize]+state[site+systemsize])
                                *sin(0.5*(state[xnegneighbour]+state[site]))
                                *sin(0.5*(state[xnegneighbour]-state[site]))
                             +cos(state[xnegneighbour+systemsize]-state[site+systemsize])
                                *cos(0.5*(state[xnegneighbour]+state[site]))
                                *cos(0.5*(state[xnegneighbour]-state[site])))
                ;
            }
            else if(y==ysize-1 && (x!=0 && x!=xsize-1)){
                //phi gradient
                gradient[site]= 
                        //alpha=phi_i-phi_j derivatives:
                        0.5*(cos(state[site+systemsize]-state[xposneighbour+systemsize])
                                *(-sin(state[site]-state[xposneighbour]))
                            +cos(state[xnegneighbour+systemsize]-state[site+systemsize])
                                *(sin(state[xnegneighbour]-state[site]))
                            +cos(state[ynegneighbour+systemsize]-state[site+systemsize])
                                *(sin(state[ynegneighbour]-state[site]))
                            +cos(state[site+systemsize]+state[xposneighbour+systemsize])
                                *(sin(state[site]-state[xposneighbour]))
                            +cos(state[xnegneighbour+systemsize]+state[site+systemsize])
                                *(-sin(state[xnegneighbour]-state[site]))
                            +cos(state[ynegneighbour+systemsize]+state[site+systemsize])
                                *(-sin(state[ynegneighbour]-state[site])))
                        -0.5*E[site]*(sin(state[site+systemsize]+state[xposneighbour+systemsize])
                                    *sin(0.5*(state[site]+state[xposneighbour]))
                                    *cos(0.5*(state[site]-state[xposneighbour]))
                                 +sin(state[site+systemsize]-state[xposneighbour+systemsize])
                                    *cos(0.5*(state[site]+state[xposneighbour]))
                                    *sin(0.5*(state[site]-state[xposneighbour])))
                        -0.5*E[xnegneighbour]*(-sin(state[xnegneighbour+systemsize]+state[site+systemsize])
                                    *sin(0.5*(state[xnegneighbour]+state[site]))
                                    *cos(0.5*(state[xnegneighbour]-state[site]))
                                 -sin(state[xnegneighbour+systemsize]-state[site+systemsize])
                                    *cos(0.5*(state[xnegneighbour]+state[site]))
                                    *sin(0.5*(state[xnegneighbour]-state[site])))
                        -0.5*E[ynegneighbour+systemsize]*(sin(state[ynegneighbour+systemsize]+state[site+systemsize])
                                    *cos(0.5*(state[ynegneighbour]-state[site]))
                                    *cos(0.5*(state[ynegneighbour]+state[site]))
                                 -sin(state[ynegneighbour+systemsize]-state[site+systemsize])
                                    *sin(0.5*(state[ynegneighbour]+state[site]))
                                    *sin(0.5*(state[ynegneighbour]-state[site])))
                        //beta = phi_i+ phi_j derivatives:
                        -0.5*E[site]*(sin(state[site+systemsize]+state[xposneighbour+systemsize])
                                    *cos(0.5*(state[site]+state[xposneighbour]))
                                    *sin(0.5*(state[site]-state[xposneighbour]))
                                 +sin(state[site+systemsize]-state[xposneighbour+systemsize])
                                    *sin(0.5*(state[site]+state[xposneighbour]))
                                    *cos(0.5*(state[site]-state[xposneighbour])))
                        -0.5*E[xnegneighbour]*(sin(state[xnegneighbour+systemsize]+state[site+systemsize])
                                    *cos(0.5*(state[xnegneighbour]+state[site]))
                                    *sin(0.5*(state[xnegneighbour]-state[site]))
                                 +sin(state[xnegneighbour+systemsize]-state[site+systemsize])
                                    *(-sin(0.5*(state[xnegneighbour]+state[site])))
                                    *cos(0.5*(state[xnegneighbour]-state[site])))
                        +0.5*E[ynegneighbour+systemsize]*(sin(state[ynegneighbour+systemsize]+state[site+systemsize])
                                    *sin(0.5*(state[ynegneighbour]-state[site]))
                                    *(-sin(0.5*(state[ynegneighbour]+state[site])))
                                 +sin(state[ynegneighbour+systemsize]-state[site+systemsize])
                                    *cos(0.5*(state[ynegneighbour]+state[site]))
                                    *cos(0.5*(state[ynegneighbour]-state[site])))
                        ;
                //theta gradient
                gradient[site+systemsize]=
                        0.5*(-sin(state[site+systemsize]-state[xposneighbour+systemsize])
                                *(cos(state[site]-state[xposneighbour])+1.0)
                             -sin(state[site+systemsize]+state[xposneighbour+systemsize])
                                *(1.0-cos(state[site]-state[xposneighbour]))
                             +sin(state[xnegneighbour+systemsize]-state[site+systemsize])
                                *(cos(state[xnegneighbour]-state[site])+1.0)
                             -sin(state[xnegneighbour+systemsize]+state[site+systemsize])
                                *(1.0-cos(state[xnegneighbour]-state[site]))
                             +sin(state[ynegneighbour+systemsize]-state[site+systemsize])
                                *(cos(state[ynegneighbour]-state[site])+1.0)
                             -sin(state[ynegneighbour+systemsize]+state[site+systemsize])
                                *(1.0-cos(state[ynegneighbour]-state[site])))
                        -E[site]*(cos(state[site+systemsize]+state[xposneighbour+systemsize])
                                *sin(0.5*(state[site]+state[xposneighbour]))
                                *sin(0.5*(state[site]-state[xposneighbour]))
                             -cos(state[site+systemsize]-state[xposneighbour+systemsize])
                                *cos(0.5*(state[site]+state[xposneighbour]))
                                *cos(0.5*(state[site]-state[xposneighbour])))
                        -E[xnegneighbour]*(cos(state[xnegneighbour+systemsize]+state[site+systemsize])
                                *sin(0.5*(state[xnegneighbour]+state[site]))
                                *sin(0.5*(state[xnegneighbour]-state[site]))
                             +cos(state[xnegneighbour+systemsize]-state[site+systemsize])
                                *cos(0.5*(state[xnegneighbour]+state[site]))
                                *cos(0.5*(state[xnegneighbour]-state[site])))
                        +E[ynegneighbour+systemsize]*(cos(state[ynegneighbour+systemsize]+state[site+systemsize])
                                *sin(0.5*(state[ynegneighbour]-state[site]))
                                *cos(0.5*(state[ynegneighbour]+state[site]))
                             -cos(state[ynegneighbour+systemsize]-state[site+systemsize])
                                *sin(0.5*(state[ynegneighbour]+state[site]))
                                *cos(0.5*(state[ynegneighbour]-state[site])))
                ;
            }
            else if(x==0 && y==0){
                //phi gradient
                gradient[site]= 
                        //alpha=phi_i-phi_j derivatives:
                        0.5*(cos(state[site+systemsize]-state[xposneighbour+systemsize])
                                *(-sin(state[site]-state[xposneighbour]))
                            +cos(state[site+systemsize]-state[yposneighbour+systemsize])
                                *(-sin(state[site]-state[yposneighbour]))
                            +cos(state[site+systemsize]+state[xposneighbour+systemsize])
                                *(sin(state[site]-state[xposneighbour]))
                            +cos(state[site+systemsize]+state[yposneighbour+systemsize])
                                *(sin(state[site]-state[yposneighbour])))
                        -0.5*E[site]*(sin(state[site+systemsize]+state[xposneighbour+systemsize])
                                    *sin(0.5*(state[site]+state[xposneighbour]))
                                    *cos(0.5*(state[site]-state[xposneighbour]))
                                 +sin(state[site+systemsize]-state[xposneighbour+systemsize])
                                    *cos(0.5*(state[site]+state[xposneighbour]))
                                    *sin(0.5*(state[site]-state[xposneighbour])))
                        +0.5*E[site+systemsize]*(sin(state[site+systemsize]+state[yposneighbour+systemsize])
                                    *cos(0.5*(state[site]-state[yposneighbour]))
                                    *cos(0.5*(state[site]+state[yposneighbour]))
                                 -sin(state[site+systemsize]-state[yposneighbour+systemsize])
                                    *sin(0.5*(state[site]+state[yposneighbour]))
                                    *sin(0.5*(state[site]-state[yposneighbour])))
                        //beta = phi_i+ phi_j derivatives:
                        -0.5*E[site]*(sin(state[site+systemsize]+state[xposneighbour+systemsize])
                                    *cos(0.5*(state[site]+state[xposneighbour]))
                                    *sin(0.5*(state[site]-state[xposneighbour]))
                                 +sin(state[site+systemsize]-state[xposneighbour+systemsize])
                                    *sin(0.5*(state[site]+state[xposneighbour]))
                                    *cos(0.5*(state[site]-state[xposneighbour])))
                        +0.5*E[site+systemsize]*(sin(state[site+systemsize]+state[yposneighbour+systemsize])
                                    *sin(0.5*(state[site]-state[yposneighbour]))
                                    *(-sin(0.5*(state[site]+state[yposneighbour])))
                                 +sin(state[site+systemsize]-state[yposneighbour+systemsize])
                                    *cos(0.5*(state[site]+state[yposneighbour]))
                                    *cos(0.5*(state[site]-state[yposneighbour])))
                ;
                //theta gradient
                gradient[site+systemsize]=
                        0.5*(-sin(state[site+systemsize]-state[xposneighbour+systemsize])
                                *(cos(state[site]-state[xposneighbour])+1.0)
                             -sin(state[site+systemsize]+state[xposneighbour+systemsize])
                                *(1.0-cos(state[site]-state[xposneighbour]))
                             -sin(state[site+systemsize]-state[yposneighbour+systemsize])
                                *(cos(state[site]-state[yposneighbour])+1.0)
                             -sin(state[site+systemsize]+state[yposneighbour+systemsize])
                                *(1.0-cos(state[site]-state[yposneighbour])))
                        -E[site]*(cos(state[site+systemsize]+state[xposneighbour+systemsize])
                                *sin(0.5*(state[site]+state[xposneighbour]))
                                *sin(0.5*(state[site]-state[xposneighbour]))
                             -cos(state[site+systemsize]-state[xposneighbour+systemsize])
                                *cos(0.5*(state[site]+state[xposneighbour]))
                                *cos(0.5*(state[site]-state[xposneighbour])))
                        +E[site+systemsize]*(cos(state[site+systemsize]+state[yposneighbour+systemsize])
                                *sin(0.5*(state[site]-state[yposneighbour]))
                                *cos(0.5*(state[site]+state[yposneighbour]))
                             +cos(state[site+systemsize]-state[yposneighbour+systemsize])
                                *cos(0.5*(state[site]-state[yposneighbour]))
                                *sin(0.5*(state[site]+state[yposneighbour])))
                ;
            }
            else if(x==0 && y==ysize-1){
                //phi gradient
                gradient[site]= 
                        //alpha=phi_i-phi_j derivatives:
                        0.5*(cos(state[site+systemsize]-state[xposneighbour+systemsize])
                                *(-sin(state[site]-state[xposneighbour]))
                            +cos(state[ynegneighbour+systemsize]-state[site+systemsize])
                                *(sin(state[ynegneighbour]-state[site]))
                            +cos(state[site+systemsize]+state[xposneighbour+systemsize])
                                *(sin(state[site]-state[xposneighbour]))
                            +cos(state[ynegneighbour+systemsize]+state[site+systemsize])
                                *(-sin(state[ynegneighbour]-state[site])))
                        -0.5*E[site]*(sin(state[site+systemsize]+state[xposneighbour+systemsize])
                                    *sin(0.5*(state[site]+state[xposneighbour]))
                                    *cos(0.5*(state[site]-state[xposneighbour]))
                                 +sin(state[site+systemsize]-state[xposneighbour+systemsize])
                                    *cos(0.5*(state[site]+state[xposneighbour]))
                                    *sin(0.5*(state[site]-state[xposneighbour])))
                        -0.5*E[ynegneighbour+systemsize]*(sin(state[ynegneighbour+systemsize]+state[site+systemsize])
                                    *cos(0.5*(state[ynegneighbour]-state[site]))
                                    *cos(0.5*(state[ynegneighbour]+state[site]))
                                 -sin(state[ynegneighbour+systemsize]-state[site+systemsize])
                                    *sin(0.5*(state[ynegneighbour]+state[site]))
                                    *sin(0.5*(state[ynegneighbour]-state[site])))
                        //beta = phi_i+ phi_j derivatives:
                        -0.5*E[site]*(sin(state[site+systemsize]+state[xposneighbour+systemsize])
                                    *cos(0.5*(state[site]+state[xposneighbour]))
                                    *sin(0.5*(state[site]-state[xposneighbour]))
                                 +sin(state[site+systemsize]-state[xposneighbour+systemsize])
                                    *sin(0.5*(state[site]+state[xposneighbour]))
                                    *cos(0.5*(state[site]-state[xposneighbour])))
                        +0.5*E[ynegneighbour+systemsize]*(sin(state[ynegneighbour+systemsize]+state[site+systemsize])
                                    *sin(0.5*(state[ynegneighbour]-state[site]))
                                    *(-sin(0.5*(state[ynegneighbour]+state[site])))
                                 +sin(state[ynegneighbour+systemsize]-state[site+systemsize])
                                    *cos(0.5*(state[ynegneighbour]+state[site]))
                                    *cos(0.5*(state[ynegneighbour]-state[site])))
                        ;
                //theta gradient
                gradient[site+systemsize]=
                        0.5*(-sin(state[site+systemsize]-state[xposneighbour+systemsize])
                                *(cos(state[site]-state[xposneighbour])+1.0)
                             -sin(state[site+systemsize]+state[xposneighbour+systemsize])
                                *(1.0-cos(state[site]-state[xposneighbour]))
                             +sin(state[ynegneighbour+systemsize]-state[site+systemsize])
                                *(cos(state[ynegneighbour]-state[site])+1.0)
                             -sin(state[ynegneighbour+systemsize]+state[site+systemsize])
                                *(1.0-cos(state[ynegneighbour]-state[site])))
                        -E[site]*(cos(state[site+systemsize]+state[xposneighbour+systemsize])
                                *sin(0.5*(state[site]+state[xposneighbour]))
                                *sin(0.5*(state[site]-state[xposneighbour]))
                             -cos(state[site+systemsize]-state[xposneighbour+systemsize])
                                *cos(0.5*(state[site]+state[xposneighbour]))
                                *cos(0.5*(state[site]-state[xposneighbour])))
                        +E[ynegneighbour+systemsize]*(cos(state[ynegneighbour+systemsize]+state[site+systemsize])
                                *sin(0.5*(state[ynegneighbour]-state[site]))
                                *cos(0.5*(state[ynegneighbour]+state[site]))
                             -cos(state[ynegneighbour+systemsize]-state[site+systemsize])
                                *sin(0.5*(state[ynegneighbour]+state[site]))
                                *cos(0.5*(state[ynegneighbour]-state[site])))
                ;
            }
            else if(x==xsize-1 && y==0){
            //phi gradient
                gradient[site]= 
                        //alpha=phi_i-phi_j derivatives:
                        0.5*(+cos(state[xnegneighbour+systemsize]-state[site+systemsize])
                                *(sin(state[xnegneighbour]-state[site]))
                            +cos(state[site+systemsize]-state[yposneighbour+systemsize])
                                *(-sin(state[site]-state[yposneighbour]))
                            +cos(state[xnegneighbour+systemsize]+state[site+systemsize])
                                *(-sin(state[xnegneighbour]-state[site]))
                            +cos(state[site+systemsize]+state[yposneighbour+systemsize])
                                *(sin(state[site]-state[yposneighbour])))
                        +0.5*E[site+systemsize]*(sin(state[site+systemsize]+state[yposneighbour+systemsize])
                                    *cos(0.5*(state[site]-state[yposneighbour]))
                                    *cos(0.5*(state[site]+state[yposneighbour]))
                                 -sin(state[site+systemsize]-state[yposneighbour+systemsize])
                                    *sin(0.5*(state[site]+state[yposneighbour]))
                                    *sin(0.5*(state[site]-state[yposneighbour])))
                        -0.5*E[xnegneighbour]*(-sin(state[xnegneighbour+systemsize]+state[site+systemsize])
                                    *sin(0.5*(state[xnegneighbour]+state[site]))
                                    *cos(0.5*(state[xnegneighbour]-state[site]))
                                 -sin(state[xnegneighbour+systemsize]-state[site+systemsize])
                                    *cos(0.5*(state[xnegneighbour]+state[site]))
                                    *sin(0.5*(state[xnegneighbour]-state[site])))
                        //beta = phi_i+ phi_j derivatives:
                        +0.5*E[site+systemsize]*(sin(state[site+systemsize]+state[yposneighbour+systemsize])
                                    *sin(0.5*(state[site]-state[yposneighbour]))
                                    *(-sin(0.5*(state[site]+state[yposneighbour])))
                                 +sin(state[site+systemsize]-state[yposneighbour+systemsize])
                                    *cos(0.5*(state[site]+state[yposneighbour]))
                                    *cos(0.5*(state[site]-state[yposneighbour])))
                        -0.5*E[xnegneighbour]*(sin(state[xnegneighbour+systemsize]+state[site+systemsize])
                                    *cos(0.5*(state[xnegneighbour]+state[site]))
                                    *sin(0.5*(state[xnegneighbour]-state[site]))
                                 +sin(state[xnegneighbour+systemsize]-state[site+systemsize])
                                    *(-sin(0.5*(state[xnegneighbour]+state[site])))
                                    *cos(0.5*(state[xnegneighbour]-state[site])))
                ;
                //theta gradient
                gradient[site+systemsize]=
                        0.5*(-sin(state[site+systemsize]-state[yposneighbour+systemsize])
                                *(cos(state[site]-state[yposneighbour])+1.0)
                             -sin(state[site+systemsize]+state[yposneighbour+systemsize])
                                *(1.0-cos(state[site]-state[yposneighbour]))
                             +sin(state[xnegneighbour+systemsize]-state[site+systemsize])
                                *(cos(state[xnegneighbour]-state[site])+1.0)
                             -sin(state[xnegneighbour+systemsize]+state[site+systemsize])
                                *(1.0-cos(state[xnegneighbour]-state[site])))
                        +E[site+systemsize]*(cos(state[site+systemsize]+state[yposneighbour+systemsize])
                                *sin(0.5*(state[site]-state[yposneighbour]))
                                *cos(0.5*(state[site]+state[yposneighbour]))
                             +cos(state[site+systemsize]-state[yposneighbour+systemsize])
                                *cos(0.5*(state[site]-state[yposneighbour]))
                                *sin(0.5*(state[site]+state[yposneighbour])))
                        -E[xnegneighbour]*(cos(state[xnegneighbour+systemsize]+state[site+systemsize])
                                *sin(0.5*(state[xnegneighbour]+state[site]))
                                *sin(0.5*(state[xnegneighbour]-state[site]))
                             +cos(state[xnegneighbour+systemsize]-state[site+systemsize])
                                *cos(0.5*(state[xnegneighbour]+state[site]))
                                *cos(0.5*(state[xnegneighbour]-state[site])))
                ;
            }
            else if(x==xsize-1 && y==ysize-1){
                //phi gradient
                gradient[site]= 
                        //alpha=phi_i-phi_j derivatives:
                        0.5*(+cos(state[xnegneighbour+systemsize]-state[site+systemsize])
                                *(sin(state[xnegneighbour]-state[site]))
                            +cos(state[ynegneighbour+systemsize]-state[site+systemsize])
                                *(sin(state[ynegneighbour]-state[site]))
                            +cos(state[xnegneighbour+systemsize]+state[site+systemsize])
                                *(-sin(state[xnegneighbour]-state[site]))
                            +cos(state[ynegneighbour+systemsize]+state[site+systemsize])
                                *(-sin(state[ynegneighbour]-state[site])))
                        -0.5*E[xnegneighbour]*(-sin(state[xnegneighbour+systemsize]+state[site+systemsize])
                                    *sin(0.5*(state[xnegneighbour]+state[site]))
                                    *cos(0.5*(state[xnegneighbour]-state[site]))
                                 -sin(state[xnegneighbour+systemsize]-state[site+systemsize])
                                    *cos(0.5*(state[xnegneighbour]+state[site]))
                                    *sin(0.5*(state[xnegneighbour]-state[site])))
                        -0.5*E[ynegneighbour+systemsize]*(sin(state[ynegneighbour+systemsize]+state[site+systemsize])
                                    *cos(0.5*(state[ynegneighbour]-state[site]))
                                    *cos(0.5*(state[ynegneighbour]+state[site]))
                                 -sin(state[ynegneighbour+systemsize]-state[site+systemsize])
                                    *sin(0.5*(state[ynegneighbour]+state[site]))
                                    *sin(0.5*(state[ynegneighbour]-state[site])))
                        //beta = phi_i+ phi_j derivatives:
                        -0.5*E[xnegneighbour]*(sin(state[xnegneighbour+systemsize]+state[site+systemsize])
                                    *cos(0.5*(state[xnegneighbour]+state[site]))
                                    *sin(0.5*(state[xnegneighbour]-state[site]))
                                 +sin(state[xnegneighbour+systemsize]-state[site+systemsize])
                                    *(-sin(0.5*(state[xnegneighbour]+state[site])))
                                    *cos(0.5*(state[xnegneighbour]-state[site])))
                        +0.5*E[ynegneighbour+systemsize]*(sin(state[ynegneighbour+systemsize]+state[site+systemsize])
                                    *sin(0.5*(state[ynegneighbour]-state[site]))
                                    *(-sin(0.5*(state[ynegneighbour]+state[site])))
                                 +sin(state[ynegneighbour+systemsize]-state[site+systemsize])
                                    *cos(0.5*(state[ynegneighbour]+state[site]))
                                    *cos(0.5*(state[ynegneighbour]-state[site])))
                ;
                //theta gradient
                gradient[site+systemsize]=
                        0.5*(+sin(state[xnegneighbour+systemsize]-state[site+systemsize])
                                *(cos(state[xnegneighbour]-state[site])+1.0)
                             -sin(state[xnegneighbour+systemsize]+state[site+systemsize])
                                *(1.0-cos(state[xnegneighbour]-state[site]))
                             +sin(state[ynegneighbour+systemsize]-state[site+systemsize])
                                *(cos(state[ynegneighbour]-state[site])+1.0)
                             -sin(state[ynegneighbour+systemsize]+state[site+systemsize])
                                *(1.0-cos(state[ynegneighbour]-state[site])))
                        -E[xnegneighbour]*(cos(state[xnegneighbour+systemsize]+state[site+systemsize])
                                *sin(0.5*(state[xnegneighbour]+state[site]))
                                *sin(0.5*(state[xnegneighbour]-state[site]))
                             +cos(state[xnegneighbour+systemsize]-state[site+systemsize])
                                *cos(0.5*(state[xnegneighbour]+state[site]))
                                *cos(0.5*(state[xnegneighbour]-state[site])))
                        +E[ynegneighbour+systemsize]*(cos(state[ynegneighbour+systemsize]+state[site+systemsize])
                                *sin(0.5*(state[ynegneighbour]-state[site]))
                                *cos(0.5*(state[ynegneighbour]+state[site]))
                             -cos(state[ynegneighbour+systemsize]-state[site+systemsize])
                                *sin(0.5*(state[ynegneighbour]+state[site]))
                                *cos(0.5*(state[ynegneighbour]-state[site])))
                ;
            }
        }
    }
    ostringstream fm;
    fm << "gradientxsize" << xsize << "ysize" << ysize << "fieldsize" << fieldsize << "D" << parameter << "cJxsize.dat";
    ofstream writezero(fm.str().c_str());
    for(int ix=0; ix<xsize;ix++){
        for(int y=0;y<ysize;y++){
            writezero << gradient[ix*ysize+y+systemsize] << '\t';
        }
        writezero << '\n';
    }
    
    return 0;
}
